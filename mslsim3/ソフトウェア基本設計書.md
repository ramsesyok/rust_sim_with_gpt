# ソフトウェア基本設計書

## 1. はじめに

本設計書は、「シミュレーション・ソフトウェア要求仕様書」を基に、Rust初心者のプログラマが迷わず実装を進められるように「ソフトウェア基本設計書」を作成したものです。本設計書では、プログラムのファイル構成、各モジュールのインタフェース、入力ファイルのデータ構造を明確にし、関数型プログラミングの原則を厳密に遵守した設計を提案します。特に、**modelsモジュール**においては、純粋関数を積極的に活用し、更新ロジックや判定ロジックを再利用可能な関数として設計します。

## 2. システム概要

本シミュレーションプログラムは、中距離弾道ミサイル、レーダ、および迎撃ミサイルの動作を時系列でシミュレーションし、その結果をCSVファイルとして出力します。以下のモジュール構成により、汎用的な数値演算とシミュレーションモデルを分離し、再利用性を高めます。

- **mathモジュール**: 汎用的な数値演算（積分計算、ローパスフィルタなど）を提供。
- **modelsモジュール**: シミュレーション対象の各オブジェクト（中距離弾道ミサイル、レーダ、迎撃ミサイル）のモデルを提供。
- **utilsモジュール**: ユーティリティ機能（設定ファイルのパースなど）を提供。

## 3. ファイル構成

Rustプロジェクトの標準的な構成に従い、以下のディレクトリおよびファイル構成とします。

```
simulation_project/
├── Cargo.toml
├── src/
│   ├── main.rs
│   ├── math/
│   │   ├── mod.rs
│   │   ├── integrator.rs
│   │   └── low_pass_filter.rs
│   ├── models/
│   │   ├── mod.rs
│   │   ├── missile.rs
│   │   ├── radar.rs
│   │   └── interceptor.rs
│   └── utils/
│       ├── mod.rs
│       └── yaml_parser.rs
├── config/
│   ├── missile_params.yaml
│   ├── radar_params.yaml
│   ├── interceptor_params.yaml
│   └── scenario.yaml
└── output/
    └── simulation_results.csv
```

### 各ディレクトリ・ファイルの説明

- `main.rs`: シミュレーションのエントリーポイント。初期化、タイムループ、終了処理を担当。
- `math/`: 汎用的な数値演算モジュール。
  - `integrator.rs`: Adams-Bashforth 2段法による数値積分を実装。
  - `low_pass_filter.rs`: 1次遅れローパスフィルタを実装。
- `models/`: シミュレーション対象のオブジェクトモデル。
  - `missile.rs`: 中距離弾道ミサイルのモデル。
  - `radar.rs`: レーダのモデル。
  - `interceptor.rs`: 迎撃ミサイルのモデル。
- `utils/`: ユーティリティモジュール。
  - `yaml_parser.rs`: YAML形式の入力ファイルをパースする機能。
- `config/`: YAML形式の設定ファイル群。
  - `missile_params.yaml`, `radar_params.yaml`, `interceptor_params.yaml`: 各モデルのパラメータファイル。
  - `scenario.yaml`: シナリオファイル。
- `output/`: シミュレーション結果の出力先。
  - `simulation_results.csv`: シミュレーション結果を格納するCSVファイル。

## 4. モジュール構成

### 4.1 mathモジュール

#### 4.1.1 integrator.rs

**機能**: Adams-Bashforth 2段法による数値積分を提供します。

**構造体および関数**:
```rust
pub struct AdamsBashforthIntegrator {
    previous_f: f64,
}

impl AdamsBashforthIntegrator {
    pub fn new() -> Self {
        AdamsBashforthIntegrator { previous_f: 0.0 }
    }

    pub fn integrate(&mut self, current_f: f64, dt: f64, previous_y: f64) -> f64 {
        let y_next = previous_y + (dt / 2.0) * (3.0 * current_f - self.previous_f);
        self.previous_f = current_f;
        y_next
    }
}
```

#### 4.1.2 low_pass_filter.rs

**機能**: 1次遅れローパスフィルタを提供します。ステートフルなオブジェクトとして前回の値を保持します。

**構造体および関数**:
```rust
pub struct LowPassFilter {
    filtered: f64,
    alpha: f64,
}

impl LowPassFilter {
    pub fn new(alpha: f64) -> Self {
        LowPassFilter {
            filtered: 0.0,
            alpha,
        }
    }

    pub fn apply(&mut self, input: f64) -> f64 {
        self.filtered = self.alpha * input + (1.0 - self.alpha) * self.filtered;
        self.filtered
    }
}
```

### 4.2 modelsモジュール

**設計方針**: modelsモジュールでは、関数型プログラミングの原則を厳密に遵守します。すべてのモデルに関連する更新ロジックや判定ロジックは、副作用を持たない純粋関数として実装し、再利用性を高めます。状態の管理は、ステートフルなオブジェクトとしてではなく、明示的に関数間で渡すデータ構造として扱います。

#### 4.2.1 missile.rs (中距離弾道ミサイル)

**構造体**:
```rust
#[derive(Clone, Debug)]
pub struct Missile {
    pub params: MissileParams,
    pub state: MissileState,
}
```

**パラメータ構造体**:
```rust
#[derive(Clone, Debug, Deserialize)]
pub struct MissileParams {
    pub alpha: f64,          // 燃料消費率係数
    pub cd: f64,             // 空気抵抗係数
    pub area: f64,           // 断面積 [m^2]
    pub rho0: f64,           // 大気密度の基準値 [kg/m^3]
    pub h: f64,              // 大気密度減衰定数 [m]
    pub g: f64,              // 重力加速度 [m/s^2]
    pub alpha_filter: f64,   // ローパスフィルタのalpha値
}
```

**初期状態構造体**:
```rust
#[derive(Clone, Debug, Deserialize)]
pub struct MissileState {
    pub mass: f64,
    pub thrust: f64,
    pub theta: f64,
    pub psi: f64,
    pub position: [f64; 3],
    pub velocity: [f64; 3],
}
```

**純粋関数**:

更新ロジックや判定ロジックを関数として実装します。以下に、`update_missile`および関連する純粋関数の詳細な分割を示します。

```rust
use crate::math::integrator::AdamsBashforthIntegrator;
use crate::math::low_pass_filter::LowPassFilter;

/// 計算ヘルパー関数

/// 座標ベクトルの差を計算
pub fn vector_subtract(a: &[f64; 3], b: &[f64; 3]) -> [f64; 3] {
    [
        a[0] - b[0],
        a[1] - b[1],
        a[2] - b[2],
    ]
}

/// ベクトルのノルムを計算
pub fn vector_norm(v: &[f64; 3]) -> f64 {
    v.iter().map(|&x| x.powi(2)).sum::<f64>().sqrt()
}

/// ベクトルの正規化
pub fn vector_normalize(v: &[f64; 3]) -> [f64; 3] {
    let norm = vector_norm(v);
    if norm == 0.0 {
        [0.0, 0.0, 0.0]
    } else {
        [v[0] / norm, v[1] / norm, v[2] / norm]
    }
}

/// 加速度計算関数
pub fn calculate_acceleration(
    params: &MissileParams,
    state: &MissileState,
) -> [f64; 3] {
    // 大気密度の計算
    let rho = params.rho0 * (-state.position[2] / params.h).exp();

    // 速度のノルム
    let speed = vector_norm(&state.velocity);

    // 空気抵抗の計算
    let drag = 0.5 * rho * params.cd * params.area * speed.powi(2);
    let drag_vector = [
        -drag * (state.velocity[0] / speed),
        -drag * (state.velocity[1] / speed),
        -drag * (state.velocity[2] / speed),
    ];

    // 重力の計算
    let gravity = [
        0.0,
        0.0,
        -params.g * state.mass,
    ];

    // 推力ベクトルの計算
    let thrust_vector = [
        params.thrust * state.theta.cos() * state.psi.cos(),
        params.thrust * state.theta.cos() * state.psi.sin(),
        params.thrust * state.theta.sin(),
    ];

    // 合力の計算
    [
        thrust_vector[0] + drag_vector[0] + gravity[0],
        thrust_vector[1] + drag_vector[1] + gravity[1],
        thrust_vector[2] + drag_vector[2] + gravity[2],
    ]
}

/// 質量更新関数
pub fn update_mass(params: &MissileParams, state: &MissileState, dt: f64) -> f64 {
    let new_mass = state.mass - params.alpha * state.thrust * dt;
    if new_mass >= 0.0 { new_mass } else { 0.0 }
}

/// 状態更新関数
pub fn update_state(
    new_position: [f64; 3],
    new_velocity: [f64; 3],
    new_mass: f64,
    state: &MissileState,
) -> MissileState {
    MissileState {
        mass: new_mass,
        thrust: state.thrust, // シナリオや制御により更新可能
        theta: state.theta,   // 制御により更新可能
        psi: state.psi,       // 制御により更新可能
        position: new_position,
        velocity: new_velocity,
    }
}

/// 運動方程式に基づきミサイルの状態を更新する関数
pub fn update_missile(
    params: &MissileParams,
    state: &MissileState,
    integrators: &mut [AdamsBashforthIntegrator; 3],
    filters: &mut [LowPassFilter; 3],
    dt: f64,
) -> MissileState {
    // 加速度の計算
    let acceleration = calculate_acceleration(params, state);

    // Adams-Bashforthによる速度の更新
    let mut new_velocity = [0.0; 3];
    for i in 0..3 {
        new_velocity[i] = integrators[i].integrate(acceleration[i], dt, state.velocity[i]);
    }

    // ローパスフィルタの適用
    for i in 0..3 {
        new_velocity[i] = filters[i].apply(new_velocity[i]);
    }

    // 位置の更新
    let new_position = [
        state.position[0] + new_velocity[0] * dt,
        state.position[1] + new_velocity[1] * dt,
        state.position[2] + new_velocity[2] * dt,
    ];

    // 質量の更新
    let new_mass = update_mass(params, state, dt);

    // 状態の更新
    let updated_state = update_state(new_position, new_velocity, new_mass, state);

    updated_state
}

/// 衝突判定関数
pub fn check_collision(state: &MissileState) -> bool {
    state.position[2] <= 0.0
}
```

#### 4.2.2 radar.rs (レーダ)

**構造体**:
```rust
#[derive(Clone, Debug)]
pub struct Radar {
    pub params: RadarParams,
}
```

**パラメータ構造体**:
```rust
#[derive(Clone, Debug, Deserialize)]
pub struct RadarParams {
    pub position: [f64; 3],          // レーダ位置 [m]
    pub direction: [f64; 3],         // レーダ基準ベクトル
    pub range: f64,                   // 探知距離 [m]
    pub azimuth_range: f64,           // 方位角カバー範囲 [度]
    pub elevation_range: f64,         // 仰角カバー範囲 [度]
    pub period: f64,                  // 探知周期 [s]
}
```

**検出結果構造体**:
```rust
#[derive(Clone, Debug)]
pub struct DetectionResult {
    pub detected: bool,
    pub missile_position: Option<[f64; 3]>,
    pub missile_orientation: Option<[f64; 3]>,
    pub detection_position: Option<[f64; 3]>,
}
```

**純粋関数**:

更新ロジックや判定ロジックを関数として実装します。以下に、`detect_missile`および関連する純粋関数の詳細な分割を示します。

```rust
use crate::models::missile::MissileState;

/// ベクトルの内積を計算
pub fn vector_dot(a: &[f64; 3], b: &[f64; 3]) -> f64 {
    a.iter().zip(b.iter()).map(|(&x, &y)| x * y).sum()
}

/// 座標ベクトルの差を計算（再利用）
pub fn vector_subtract(a: &[f64; 3], b: &[f64; 3]) -> [f64; 3] {
    [
        a[0] - b[0],
        a[1] - b[1],
        a[2] - b[2],
    ]
}

/// ベクトルのノルムを計算（再利用）
pub fn vector_norm(v: &[f64; 3]) -> f64 {
    v.iter().map(|&x| x.powi(2)).sum::<f64>().sqrt()
}

/// ベクトルの正規化（再利用）
pub fn vector_normalize(v: &[f64; 3]) -> [f64; 3] {
    let norm = vector_norm(v);
    if norm == 0.0 {
        [0.0, 0.0, 0.0]
    } else {
        [v[0] / norm, v[1] / norm, v[2] / norm]
    }
}

/// 方位角差の計算関数
pub fn calculate_delta_azimuth(radar_dir: &[f64; 3], target_dir: &[f64; 3]) -> f64 {
    let dot = vector_dot(radar_dir, target_dir);
    let delta = dot.acos().to_degrees();
    delta
}

/// 仰角差の計算関数
pub fn calculate_delta_elevation(radar_dir: &[f64; 3], target_dir: &[f64; 3]) -> f64 {
    let dot = vector_dot(radar_dir, target_dir);
    let norm_product = vector_norm(radar_dir) * vector_norm(target_dir);
    if norm_product == 0.0 {
        0.0
    } else {
        (dot / norm_product).acos().to_degrees()
    }
}

/// `atan2`のゼロ近傍判定関数
pub fn is_atan2_near_zero(x: f64, y: f64, epsilon: f64) -> bool {
    x.abs() < epsilon && y.abs() < epsilon
}

/// 探知関数: 距離判定
pub fn distance_check(radar: &Radar, missile: &MissileState) -> bool {
    let relative_position = vector_subtract(&missile.position, &radar.params.position);
    let distance = vector_norm(&relative_position);
    distance <= radar.params.range
}

/// 探知関数: 角度判定
pub fn angle_check(radar: &Radar, missile: &MissileState, epsilon: f64) -> bool {
    let relative_position = vector_subtract(&missile.position, &radar.params.position);
    let distance = vector_norm(&relative_position);
    let target_direction = if distance == 0.0 {
        [0.0, 0.0, 0.0]
    } else {
        vector_normalize(&relative_position)
    };
    let radar_direction = vector_normalize(&radar.params.direction);

    // atan2のゼロ近傍判定
    if is_atan2_near_zero(radar.params.direction[0], radar.params.direction[1], epsilon) &&
       is_atan2_near_zero(target_direction[0], target_direction[1], epsilon) {
        return false;
    }

    let delta_azimuth = calculate_delta_azimuth(&radar_direction, &target_direction);
    let delta_elevation = calculate_delta_elevation(&radar_direction, &target_direction);

    delta_azimuth <= (radar.params.azimuth_range / 2.0) &&
    delta_elevation <= (radar.params.elevation_range / 2.0)
}

/// 探知関数: 全体判定
pub fn detect_missile(
    radar: &Radar,
    missile: &MissileState,
    epsilon: f64,
) -> DetectionResult {
    let detected = distance_check(radar, missile) && angle_check(radar, missile, epsilon);

    if detected {
        DetectionResult {
            detected: true,
            missile_position: Some(missile.position),
            missile_orientation: Some([missile.theta, missile.psi, 0.0]),
            detection_position: Some(radar.params.position),
        }
    } else {
        DetectionResult {
            detected: false,
            missile_position: None,
            missile_orientation: None,
            detection_position: None,
        }
    }
}

/// 発射指示を生成する関数
pub fn generate_fire_command(detection: &DetectionResult) -> bool {
    detection.detected
}
```

#### 4.2.3 interceptor.rs (迎撃ミサイル)

**構造体**:
```rust
#[derive(Clone, Debug)]
pub struct Interceptor {
    pub params: InterceptorParams,
    pub state: InterceptorState,
}
```

**パラメータ構造体**:
```rust
#[derive(Clone, Debug, Deserialize)]
pub struct GuidanceConstants {
    pub n: f64, // 比例航法定数
    // 他の比例航法関連定数
}

#[derive(Clone, Debug, Deserialize)]
pub struct InterceptorParams {
    pub alpha: f64,                    // 燃料消費率係数
    pub cd: f64,                       // 空気抵抗係数
    pub area: f64,                     // 断面積 [m^2]
    pub g: f64,                        // 重力加速度 [m/s^2]
    pub thrust: f64,                   // 推力 [N]
    pub alpha_filter: f64,             // ローパスフィルタのalpha値
    pub guidance_constants: GuidanceConstants,
}
```

**初期状態構造体**:
```rust
#[derive(Clone, Debug, Deserialize)]
pub struct InterceptorState {
    pub mass: f64,
    pub thrust: f64,
    pub theta: f64,
    pub psi: f64,
    pub position: [f64; 3],
    pub velocity: [f64; 3],
    pub launched: bool,
}
```

**純粋関数**:

更新ロジックや判定ロジックを関数として実装します。以下に、`update_interceptor`および関連する純粋関数の詳細な分割を示します。

```rust
use crate::math::integrator::AdamsBashforthIntegrator;
use crate::math::low_pass_filter::LowPassFilter;
use crate::models::missile::MissileState;

/// 誘導加速度計算関数（比例航法）
pub fn guidance(
    interceptor: &InterceptorState,
    target_position: &[f64; 3],
    guidance_constants: &GuidanceConstants,
) -> [f64; 3] {
    let los = vector_subtract(&target_position, &interceptor.position);
    let los_norm = vector_norm(&los);
    let los_unit = if los_norm == 0.0 {
        [0.0, 0.0, 0.0]
    } else {
        vector_normalize(&los)
    };

    // LOS角速度（簡略化のためにゼロとする）
    let lambda_dot = 0.0;

    // 誘導加速度の計算
    [
        guidance_constants.n * interceptor.velocity[0] * lambda_dot * los_unit[0],
        guidance_constants.n * interceptor.velocity[1] * lambda_dot * los_unit[1],
        guidance_constants.n * interceptor.velocity[2] * lambda_dot * los_unit[2],
    ]
}

/// 空気抵抗計算関数
pub fn calculate_drag(
    cd: f64,
    area: f64,
    velocity: &[f64; 3],
) -> [f64; 3] {
    let speed = vector_norm(velocity);
    let drag = 0.5 * cd * area * speed.powi(2);
    [
        -drag * (velocity[0] / speed),
        -drag * (velocity[1] / speed),
        -drag * (velocity[2] / speed),
    ]
}

/// 重力計算関数
pub fn calculate_gravity(g: f64, mass: f64) -> [f64; 3] {
    [0.0, 0.0, -g * mass]
}

/// 推力ベクトル計算関数
pub fn calculate_thrust(thrust: f64, theta: f64, psi: f64) -> [f64; 3] {
    [
        thrust * theta.cos() * psi.cos(),
        thrust * theta.cos() * psi.sin(),
        thrust * theta.sin(),
    ]
}

/// 合力計算関数
pub fn calculate_total_force(
    thrust: &[f64; 3],
    drag: &[f64; 3],
    gravity: &[f64; 3],
    guidance_acceleration: &[f64; 3],
    mass: f64,
) -> [f64; 3] {
    [
        thrust[0] + drag[0] + gravity[0] + guidance_acceleration[0] * mass,
        thrust[1] + drag[1] + gravity[1] + guidance_acceleration[1] * mass,
        thrust[2] + drag[2] + gravity[2] + guidance_acceleration[2] * mass,
    ]
}

/// 加速度計算関数
pub fn calculate_acceleration(total_force: &[f64; 3], mass: f64) -> [f64; 3] {
    [
        total_force[0] / mass,
        total_force[1] / mass,
        total_force[2] / mass,
    ]
}

/// 質量更新関数
pub fn update_mass_interceptor(alpha: f64, thrust: f64, dt: f64) -> f64 {
    let new_mass = thrust * alpha * dt;
    new_mass
}

/// 状態更新関数
pub fn update_state_interceptor(
    new_position: [f64; 3],
    new_velocity: [f64; 3],
    new_mass: f64,
    state: &InterceptorState,
) -> InterceptorState {
    InterceptorState {
        mass: new_mass,
        thrust: state.thrust, // シナリオや制御により更新可能
        theta: state.theta,   // 誘導により更新可能
        psi: state.psi,       // 誘導により更新可能
        position: new_position,
        velocity: new_velocity,
        launched: state.launched,
    }
}

/// 迎撃ミサイルの状態を更新する関数
pub fn update_interceptor(
    params: &InterceptorParams,
    state: &InterceptorState,
    target_position: &[f64; 3],
    integrators: &mut [AdamsBashforthIntegrator; 3],
    filters: &mut [LowPassFilter; 3],
    dt: f64,
) -> InterceptorState {
    if !state.launched {
        return state.clone();
    }

    // 誘導加速度の計算
    let a_guidance = guidance(state, target_position, &params.guidance_constants);

    // 空気抵抗の計算
    let drag = calculate_drag(params.cd, params.area, &state.velocity);

    // 重力の計算
    let gravity = calculate_gravity(params.g, state.mass);

    // 推力ベクトルの計算
    let thrust = calculate_thrust(params.thrust, state.theta, state.psi);

    // 合力の計算
    let total_force = calculate_total_force(&thrust, &drag, &gravity, &a_guidance, state.mass);

    // 加速度の計算
    let acceleration = calculate_acceleration(&total_force, state.mass);

    // Adams-Bashforthによる速度の更新
    let mut new_velocity = [0.0; 3];
    for i in 0..3 {
        new_velocity[i] = integrators[i].integrate(acceleration[i], dt, state.velocity[i]);
    }

    // ローパスフィルタの適用
    for i in 0..3 {
        new_velocity[i] = filters[i].apply(new_velocity[i]);
    }

    // 位置の更新
    let new_position = [
        state.position[0] + new_velocity[0] * dt,
        state.position[1] + new_velocity[1] * dt,
        state.position[2] + new_velocity[2] * dt,
    ];

    // 質量の更新
    let new_mass = update_mass_interceptor(params.alpha, state.thrust, dt);
    let mass = if new_mass >= 0.0 { new_mass } else { 0.0 };

    // 状態の更新
    let updated_state = update_state_interceptor(new_position, new_velocity, mass, state);

    updated_state
}

/// 発射関数
pub fn launch_interceptor(state: &InterceptorState) -> InterceptorState {
    InterceptorState {
        launched: true,
        ..*state
    }
}

/// 迎撃判定関数
pub fn check_interception(
    interceptor: &InterceptorState,
    missile: &MissileState,
    interception_distance: f64,
) -> bool {
    let relative_position = vector_subtract(&interceptor.position, &missile.position);
    vector_norm(&relative_position) <= interception_distance
}
```

## 5. データ構造

### 5.1 入力ファイルデータ構造

すべての設定ファイルはYAML形式で記述されます。

#### 5.1.1 パラメータファイル例 (`missile_params.yaml`)

```yaml
alpha: 0.01          # 燃料消費率係数
cd: 0.5              # 空気抵抗係数
area: 1.0            # 断面積 [m^2]
rho0: 1.225          # 大気密度の基準値 [kg/m^3]
h: 8500.0            # 大気密度減衰定数 [m]
g: 9.81              # 重力加速度 [m/s^2]
alpha_filter: 0.1    # ローパスフィルタのalpha値
```

#### 5.1.2 レーダパラメータファイル例 (`radar_params.yaml`)

```yaml
position: [0.0, 0.0, 0.0]             # レーダ位置 [m]
direction: [1.0, 0.0, 0.0]            # レーダ基準ベクトル
range: 100000.0                       # 探知距離 [m]
azimuth_range: 45.0                   # 方位角カバー範囲 [度]
elevation_range: 30.0                 # 仰角カバー範囲 [度]
period: 0.1                           # 探知周期 [s]
```

#### 5.1.3 迎撃ミサイルパラメータファイル例 (`interceptor_params.yaml`)

```yaml
alpha: 0.02                          # 燃料消費率係数
cd: 0.4                              # 空気抵抗係数
area: 0.8                            # 断面積 [m^2]
g: 9.81                              # 重力加速度 [m/s^2]
thrust: 3000.0                       # 推力 [N]
alpha_filter: 0.1                    # ローパスフィルタのalpha値
guidance_constants:
  n: 0.1                             # 比例航法定数
```

#### 5.1.4 シナリオファイル例 (`scenario.yaml`)

```yaml
initial_conditions:
  missiles:
    - mass: 1000.0
      thrust: 5000.0
      theta: 0.0
      psi: 0.0
      position: [0.0, 0.0, 0.0]
      velocity: [100.0, 0.0, 100.0]
  interceptors:
    - mass: 500.0
      thrust: 3000.0
      theta: 0.0
      psi: 0.0
      position: [0.0, 0.0, 0.0]
      velocity: [0.0, 0.0, 0.0]
# その他のシナリオ設定
```

### 5.2 出力データ構造

シミュレーション結果はCSVファイルとして出力されます。ヘッダーには変数名と単位を記載します。

#### 5.2.1 CSVヘッダー例

```
time[s],missile1_x[m],missile1_y[m],missile1_z[m],missile1_theta[rad],missile1_psi[rad],radar_detected,radar_detection_x[m],radar_detection_y[m],radar_detection_z[m],interceptor1_x[m],interceptor1_y[m],interceptor1_z[m]
```

#### 5.2.2 データ行例

```
0.0,0.0,0.0,0.0,0.0,0.0,false,, , ,0.0,0.0,0.0
0.1,10.0,0.0,10.0,0.0,0.0,true,10.0,0.0,10.0,0.0,0.0,0.0
...
```

## 6. 関数型プログラミングの原則遵守

本設計では、関数型プログラミングの原則を厳密に順守します。具体的には、副作用を持たない純粋関数の使用を推奨し、状態の管理は関数間で明示的に行います。更新ロジックや判定ロジックは再利用可能な関数として実装し、オブジェクト指向的なメソッドの使用を避けます。

### 6.1 純粋関数の利用

数値演算や物理計算においては、副作用を持たない純粋関数として実装します。これにより、テストの容易性や再利用性を高めます。例えば、ミサイルの運動更新やレーダの検出ロジックは、入力状態とパラメータを受け取り、新しい状態を返す形で実装します。

### 6.2 ステートフルオブジェクトの使用

数値積分およびローパスフィルタにおいては、前回の計算結果を保持する必要があるため、ステートフルなオブジェクトとして設計します。これらは`math`モジュール内で管理し、他のモジュールからはインスタンスを通じて利用します。これにより、関数型の純粋性を保ちながら必要な状態管理を実現します。

## 7. インタフェース設計

### 7.1 モジュール間のインタフェース

- **main.rs ↔ modelsモジュール**: シミュレーションの初期化、オブジェクトの生成、タイムループの制御。
- **modelsモジュール ↔ mathモジュール**: 数値積分やローパスフィルタの機能を利用。
- **utilsモジュール ↔ modelsモジュール**: YAMLファイルからのパラメータ読み込み。

### 7.2 データの流れ

1. **初期化**: `main.rs`が`utils::yaml_parser`を使用して、各パラメータファイルおよびシナリオファイルを読み込む。
2. **オブジェクト生成**: 読み込んだデータを基に、`models`モジュール内の各オブジェクト（ミサイル、レーダ、迎撃ミサイル）を生成。
3. **タイムループ**: 各タイムステップで、純粋関数を用いてオブジェクトの状態を更新し、レーダによる検出および迎撃指示を行う。
4. **結果出力**: 各タイムステップの結果をCSVファイルに書き出す。

## 8. 入力ファイルのデータ構造

### 8.1 パラメータファイル

各モデルごとのパラメータファイルはYAML形式で記述し、以下のデータ構造とします。

#### 8.1.1 中距離弾道ミサイルパラメータ (`missile_params.yaml`)

```yaml
alpha: 0.01          # 燃料消費率係数
cd: 0.5              # 空気抵抗係数
area: 1.0            # 断面積 [m^2]
rho0: 1.225          # 大気密度の基準値 [kg/m^3]
h: 8500.0            # 大気密度減衰定数 [m]
g: 9.81              # 重力加速度 [m/s^2]
alpha_filter: 0.1    # ローパスフィルタのalpha値
```

#### 8.1.2 レーダパラメータ (`radar_params.yaml`)

```yaml
position: [0.0, 0.0, 0.0]             # レーダ位置 [m]
direction: [1.0, 0.0, 0.0]            # レーダ基準ベクトル
range: 100000.0                       # 探知距離 [m]
azimuth_range: 45.0                   # 方位角カバー範囲 [度]
elevation_range: 30.0                 # 仰角カバー範囲 [度]
period: 0.1                           # 探知周期 [s]
```

#### 8.1.3 迎撃ミサイルパラメータ (`interceptor_params.yaml`)

```yaml
alpha: 0.02                          # 燃料消費率係数
cd: 0.4                              # 空気抵抗係数
area: 0.8                            # 断面積 [m^2]
g: 9.81                              # 重力加速度 [m/s^2]
thrust: 3000.0                       # 推力 [N]
alpha_filter: 0.1                    # ローパスフィルタのalpha値
guidance_constants:
  n: 0.1                             # 比例航法定数
```

### 8.2 シナリオファイル (`scenario.yaml`)

シナリオファイルには、各オブジェクトの初期状態を記述します。

```yaml
initial_conditions:
  missiles:
    - mass: 1000.0
      thrust: 5000.0
      theta: 0.0
      psi: 0.0
      position: [0.0, 0.0, 0.0]
      velocity: [100.0, 0.0, 100.0]
  interceptors:
    - mass: 500.0
      thrust: 3000.0
      theta: 0.0
      psi: 0.0
      position: [0.0, 0.0, 0.0]
      velocity: [0.0, 0.0, 0.0]
# その他のシナリオ設定
```

## 9. 出力データの構造

シミュレーションの結果は、以下の形式でCSVファイルに出力します。

### 9.1 CSVファイル構造

- **ヘッダー**: 各列の変数名と単位を記載。
- **データ行**: タイムステップごとの各オブジェクトの状態およびレーダの探知状況を記載。

#### 9.1.1 ヘッダー例

```
time[s],missile1_x[m],missile1_y[m],missile1_z[m],missile1_theta[rad],missile1_psi[rad],radar_detected,radar_detection_x[m],radar_detection_y[m],radar_detection_z[m],interceptor1_x[m],interceptor1_y[m],interceptor1_z[m]
```

#### 9.1.2 データ行例

```
0.0,0.0,0.0,0.0,0.0,0.0,false,, , ,0.0,0.0,0.0
0.1,10.0,0.0,10.0,0.0,0.0,true,10.0,0.0,10.0,0.0,0.0,0.0
...
```

## 10. モジュールおよびデータ構造の詳細

### 10.1 mathモジュール

#### 10.1.1 数値積分 (Adams-Bashforth 2段法)

**目的**: ミサイルや迎撃ミサイルの位置・速度・加速度を時間ステップごとに更新するために使用します。

**実装ポイント**:
- 前回の微分値を保持するため、`AdamsBashforthIntegrator`構造体を使用。
- `integrate`メソッドにより、現在の微分値と前回の微分値から次の値を計算。

#### 10.1.2 ローパスフィルタ

**目的**: 数値振動を抑制するために、位置や速度などのデータにローパスフィルタを適用します。

**実装ポイント**:
- 前回のフィルタ値を保持するため、`LowPassFilter`構造体を使用。
- `apply`メソッドにより、現在の入力値と前回のフィルタ値から新しいフィルタ値を計算。

### 10.2 modelsモジュール

#### 10.2.1 中距離弾道ミサイル

**機能**:
- 運動方程式に基づき、推力、空気抵抗、重力の影響を受けて位置・速度・加速度を更新。
- 燃料消費による質量の変化を管理。
- 地表衝突フラグを設定。

**データ構造**:
- パラメータと初期状態を構造体として保持。

**関数型設計の詳細**:
- **更新関数**: `update_missile` は現在の状態とパラメータを受け取り、新しい状態を返します。ステートフルな処理は`math`モジュール内で管理します。
- **判定関数**: `check_collision` はミサイルが地表に衝突したかを判定します。

#### 10.2.2 レーダ

**機能**:
- ミサイルの位置を検出範囲および角度範囲内で判定。
- 探知成功時に迎撃ミサイルに発射指示を出す。
- 探知周期ごとにミサイル位置を受信。

**データ構造**:
- レーダの位置、方向、検出範囲などの固定パラメータを保持。

**関数型設計の詳細**:
- **検出関数**: `detect_missile` はレーダとミサイルの状態を受け取り、検出結果を返します。
- **発射指示関数**: `generate_fire_command` は検出結果を受け取り、迎撃ミサイルへの発射指示を生成します。

#### 10.2.3 迎撃ミサイル

**機能**:
- レーダからの発射指示を受けて起動。
- 誘導ロジック（比例航法など）に基づき、目標ミサイルを追尾・迎撃。
- 運動方程式に基づき、位置・速度・加速度を更新。

**データ構造**:
- パラメータと初期状態を構造体として保持。

**関数型設計の詳細**:
- **誘導関数**: `guidance` は迎撃ミサイルと目標ミサイルの位置を受け取り、誘導加速度を計算します。
- **更新関数**: `update_interceptor` は現在の状態と誘導加速度を受け取り、新しい状態を返します。
- **発射関数**: `launch_interceptor` は迎撃ミサイルの発射を開始します。
- **迎撃判定関数**: `check_interception` は迎撃ミサイルと目標ミサイルの位置を受け取り、迎撃成功を判定します。

### 10.3 utilsモジュール

#### 10.3.1 yaml_parser.rs

**機能**:
- YAML形式の設定ファイルをパースし、各モデルのパラメータおよびシナリオ初期状態を構造体にマッピングします。

**実装ポイント**:
- `serde`クレートを使用してYAMLをRust構造体にデシリアライズ。
- 各パラメータファイルおよびシナリオファイルに対応する構造体を定義。

**コード例**:
```rust
use serde::Deserialize;
use std::fs::File;
use std::io::Read;

#[derive(Debug, Deserialize)]
pub struct MissileParams {
    pub alpha: f64,
    pub cd: f64,
    pub area: f64,
    pub rho0: f64,
    pub h: f64,
    pub g: f64,
    pub alpha_filter: f64,
}

#[derive(Debug, Deserialize)]
pub struct RadarParams {
    pub position: [f64; 3],
    pub direction: [f64; 3],
    pub range: f64,
    pub azimuth_range: f64,
    pub elevation_range: f64,
    pub period: f64,
}

#[derive(Debug, Deserialize)]
pub struct GuidanceConstants {
    pub n: f64,
}

#[derive(Debug, Deserialize)]
pub struct InterceptorParams {
    pub alpha: f64,
    pub cd: f64,
    pub area: f64,
    pub g: f64,
    pub thrust: f64,
    pub alpha_filter: f64,
    pub guidance_constants: GuidanceConstants,
}

#[derive(Debug, Deserialize)]
pub struct MissileState {
    pub mass: f64,
    pub thrust: f64,
    pub theta: f64,
    pub psi: f64,
    pub position: [f64; 3],
    pub velocity: [f64; 3],
}

#[derive(Debug, Deserialize)]
pub struct InterceptorState {
    pub mass: f64,
    pub thrust: f64,
    pub theta: f64,
    pub psi: f64,
    pub position: [f64; 3],
    pub velocity: [f64; 3],
    pub launched: bool,
}

#[derive(Debug, Deserialize)]
pub struct Scenario {
    pub initial_conditions: InitialConditions,
}

#[derive(Debug, Deserialize)]
pub struct InitialConditions {
    pub missiles: Vec<MissileState>,
    pub interceptors: Vec<InterceptorState>,
}

pub fn parse_yaml<T: for<'de> Deserialize<'de>>(file_path: &str) -> Result<T, Box<dyn std::error::Error>> {
    let mut file = File::open(file_path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    let data = serde_yaml::from_str::<T>(&contents)?;
    Ok(data)
}
```

## 11. テスト計画

### 11.1 ユニットテスト

各モジュールおよび関数に対してユニットテストを実装し、正確な動作を検証します。

- **mathモジュール**:
  - `AdamsBashforthIntegrator`の積分精度テスト。
  - `LowPassFilter`のフィルタリング動作テスト。
- **modelsモジュール**:
  - ミサイル、レーダ、迎撃ミサイルの運動方程式の正確性テスト。
  - レーダの検出ロジックのテスト。
  - 迎撃ミサイルの誘導ロジックのテスト。
- **utilsモジュール**:
  - YAMLパーサの正確なデシリアライズテスト。

### 11.2 プロパティテスト

数値安定性や境界条件に関するプロパティテストを実施します。

- **数値安定性**:
  - 適切な`dt`の設定により、シミュレーションが数値発散しないことを確認。
- **境界条件**:
  - ミサイルが地表に到達した際の終了条件の確認。
  - `atan2`関数のゼロ近傍判定の動作確認。
  - 迎撃ミサイルが目標を迎撃した際の終了条件の確認。

## 12. 実装上の留意事項

### 12.1 数値型

- デフォルトで`f64`を使用しますが、パフォーマンスやメモリ使用量に応じて`f32`への変更も検討します。
- 高精度が要求される場合は、`Decimal`型の使用も検討します。

### 12.2 モジュール分割

- **汎用数値演算**: `math`モジュール内で管理し、他のシミュレーションモデルから独立して利用可能とします。
- **シミュレーションモデル**: `models`モジュール内で管理し、各オブジェクトごとに分割します。
- **ユーティリティ機能**: `utils`モジュール内で管理し、設定ファイルのパースなどを担当します。

### 12.3 並列化

- Rustの所有権モデルを活用しつつ、可能な箇所で並列処理を導入します。例えば、複数のミサイルオブジェクトの運動計算は並列化が可能です。
- 並列化に際しては、ステートフルなオブジェクトの共有を避け、関数型設計に基づくデータの分離を徹底します。

### 12.4 エラーハンドリング

- YAMLファイルのパースエラーや数値計算でのエラー（負の質量、`atan2`のゼロ近傍判定など）を適切にハンドリングし、ユーザに有用なエラーメッセージを提供します。
- エラー発生時には、シミュレーションを安全に停止し、ログに詳細情報を記録します。

## 13. パフォーマンス要件

### 13.1 シミュレーション時間

- シミュレーションは数分から数十分で完了することを目標とします。必要に応じて、アルゴリズムの最適化や並列化を検討します。

### 13.2 拡張性

- 複数のミサイルや迎撃ミサイルを追加しても、同一のルーチンで対応可能な設計とします。データ駆動型の設計を採用し、シナリオファイルの拡張性を確保します。

## 14. エラー処理・数値安定性

### 14.1 `atan2`のゼロ近傍判定

- `atan2`関数の入力で、`|x| < ε`かつ`|y| < ε`の場合にエラーや警告を発します。`ε`は小さな閾値として設定します（例: `1e-6`）。
- この判定は、`detect_missile`関数内で実施し、エラー時には検出失敗とします。

### 14.2 無限大・NaNのチェック

- 計算結果に無限大やNaNが含まれる場合、シミュレーションを停止し、エラーメッセージを出力します。
- `math`モジュール内で、積分やフィルタリング後に値を検証します。

### 14.3 負の質量のチェック

- 燃料消費による質量計算で、`m(t) >= 0`を常に確認します。負の質量となった場合、エラーを発生させシミュレーションを停止します。
- `update_missile`および`update_interceptor`関数内で、質量の更新後にチェックを行います。

## 15. 実装例

以下に、`models`モジュールにおける関数型設計の実装例を示します。

### 15.1 ミサイルの更新関数

```rust
use crate::math::integrator::AdamsBashforthIntegrator;
use crate::math::low_pass_filter::LowPassFilter;

/// ミサイルの状態を更新する純粋関数
pub fn update_missile(
    params: &MissileParams,
    state: &MissileState,
    integrators: &mut [AdamsBashforthIntegrator; 3],
    filters: &mut [LowPassFilter; 3],
    dt: f64,
) -> MissileState {
    // 加速度の計算
    let acceleration = calculate_acceleration(params, state);

    // Adams-Bashforthによる速度の更新
    let mut new_velocity = [0.0; 3];
    for i in 0..3 {
        new_velocity[i] = integrators[i].integrate(acceleration[i], dt, state.velocity[i]);
    }

    // ローパスフィルタの適用
    for i in 0..3 {
        new_velocity[i] = filters[i].apply(new_velocity[i]);
    }

    // 位置の更新
    let new_position = [
        state.position[0] + new_velocity[0] * dt,
        state.position[1] + new_velocity[1] * dt,
        state.position[2] + new_velocity[2] * dt,
    ];

    // 質量の更新
    let new_mass = update_mass(params, state, dt);

    // 状態の更新
    let updated_state = update_state(new_position, new_velocity, new_mass, state);

    updated_state
}

/// 衝突判定関数
pub fn check_collision(state: &MissileState) -> bool {
    state.position[2] <= 0.0
}
```

### 15.2 レーダの検出関数

```rust
use crate::models::missile::MissileState;

/// レーダによるミサイルの検出関数
pub fn detect_missile(
    radar: &Radar,
    missile: &MissileState,
    epsilon: f64,
) -> DetectionResult {
    // 距離判定
    let relative_position = vector_subtract(&missile.position, &radar.params.position);
    let distance = vector_norm(&relative_position);
    if distance > radar.params.range {
        return DetectionResult {
            detected: false,
            missile_position: None,
            missile_orientation: None,
            detection_position: None,
        };
    }

    // 角度判定
    let target_direction = if distance == 0.0 {
        [0.0, 0.0, 0.0]
    } else {
        vector_normalize(&relative_position)
    };
    let radar_direction = vector_normalize(&radar.params.direction);

    // atan2のゼロ近傍判定
    if is_atan2_near_zero(radar.params.direction[0], radar.params.direction[1], epsilon) &&
       is_atan2_near_zero(target_direction[0], target_direction[1], epsilon) {
        // エラーや警告を返す（ここでは検出失敗とする）
        return DetectionResult {
            detected: false,
            missile_position: None,
            missile_orientation: None,
            detection_position: None,
        };
    }

    let delta_azimuth = calculate_delta_azimuth(&radar_direction, &target_direction);
    let delta_elevation = calculate_delta_elevation(&radar_direction, &target_direction);

    if delta_azimuth <= (radar.params.azimuth_range / 2.0) &&
       delta_elevation <= (radar.params.elevation_range / 2.0) {
        DetectionResult {
            detected: true,
            missile_position: Some(missile.position),
            missile_orientation: Some([missile.theta, missile.psi, 0.0]),
            detection_position: Some(radar.params.position),
        }
    } else {
        DetectionResult {
            detected: false,
            missile_position: None,
            missile_orientation: None,
            detection_position: None,
        }
    }
}

/// 発射指示を生成する関数
pub fn generate_fire_command(detection: &DetectionResult) -> bool {
    detection.detected
}
```

### 15.3 迎撃ミサイルの更新関数

```rust
use crate::math::integrator::AdamsBashforthIntegrator;
use crate::math::low_pass_filter::LowPassFilter;

/// 迎撃ミサイルの状態を更新する純粋関数
pub fn update_interceptor(
    params: &InterceptorParams,
    state: &InterceptorState,
    target_position: &[f64; 3],
    integrators: &mut [AdamsBashforthIntegrator; 3],
    filters: &mut [LowPassFilter; 3],
    dt: f64,
) -> InterceptorState {
    if !state.launched {
        return state.clone();
    }

    // 誘導加速度の計算
    let a_guidance = guidance(state, target_position, &params.guidance_constants);

    // 空気抵抗の計算
    let drag = calculate_drag(params.cd, params.area, &state.velocity);

    // 重力の計算
    let gravity = calculate_gravity(params.g, state.mass);

    // 推力ベクトルの計算
    let thrust = calculate_thrust(params.thrust, state.theta, state.psi);

    // 合力の計算
    let total_force = calculate_total_force(&thrust, &drag, &gravity, &a_guidance, state.mass);

    // 加速度の計算
    let acceleration = calculate_acceleration(&total_force, state.mass);

    // Adams-Bashforthによる速度の更新
    let mut new_velocity = [0.0; 3];
    for i in 0..3 {
        new_velocity[i] = integrators[i].integrate(acceleration[i], dt, state.velocity[i]);
    }

    // ローパスフィルタの適用
    for i in 0..3 {
        new_velocity[i] = filters[i].apply(new_velocity[i]);
    }

    // 位置の更新
    let new_position = [
        state.position[0] + new_velocity[0] * dt,
        state.position[1] + new_velocity[1] * dt,
        state.position[2] + new_velocity[2] * dt,
    ];

    // 質量の更新
    let new_mass = update_mass_interceptor(params.alpha, state.thrust, dt);
    let mass = if new_mass >= 0.0 { new_mass } else { 0.0 };

    // 状態の更新
    let updated_state = update_state_interceptor(new_position, new_velocity, mass, state);

    updated_state
}

/// 迎撃ミサイルの発射関数
pub fn launch_interceptor(state: &InterceptorState) -> InterceptorState {
    InterceptorState {
        launched: true,
        ..*state
    }
}

/// 迎撃判定関数
pub fn check_interception(
    interceptor: &InterceptorState,
    missile: &MissileState,
    interception_distance: f64,
) -> bool {
    let relative_position = vector_subtract(&interceptor.position, &missile.position);
    vector_norm(&relative_position) <= interception_distance
}
```

## 16. 実行フロー (概略)

1. **初期化**
   - `main.rs`が`utils::yaml_parser`を使用して、各パラメータファイルおよびシナリオファイルを読み込む。
   - 読み込んだデータを基に、ミサイル、レーダ、迎撃ミサイルの初期状態を設定。

2. **タイムループ**
   - 現在の時刻`time`を0から開始し、各オブジェクトの状態を更新する。
   - ミサイルの状態を`update_missile`関数で更新。
   - レーダによるミサイルの検出を`detect_missile`関数で実施。
   - 検出結果に基づき、`generate_fire_command`関数で迎撃ミサイルの発射を決定。
   - 迎撃ミサイルが発射された場合、`launch_interceptor`関数で迎撃ミサイルの発射を開始。
   - 迎撃ミサイルの状態を`update_interceptor`関数で更新。
   - 各オブジェクトの終了条件を`check_collision`や`check_interception`関数でチェック。
   - シミュレーション結果をCSVファイルに書き出す。

3. **終了**
   - すべてのオブジェクトが終了条件に達したら、シミュレーションを終了。

## 17. エラー処理・数値安定性

### 17.1 `atan2`のゼロ近傍判定

- `atan2`関数の入力で、`|x| < ε`かつ`|y| < ε`の場合にエラーや警告を発します。`ε`は小さな閾値として設定します（例: `1e-6`）。
- この判定は、`detect_missile`関数内で実施し、エラー時には検出失敗とします。

### 17.2 無限大・NaNのチェック

- 計算結果に無限大やNaNが含まれる場合、シミュレーションを停止し、エラーメッセージを出力します。
- `math`モジュール内で、積分やフィルタリング後に値を検証します。

### 17.3 負の質量のチェック

- 燃料消費による質量計算で、`m(t) >= 0`を常に確認します。負の質量となった場合、エラーを発生させシミュレーションを停止します。
- `update_missile`および`update_interceptor`関数内で、質量の更新後にチェックを行います。

## 18. 実装上の留意事項

### 18.1 数値型

- デフォルトで`f64`を使用しますが、パフォーマンスやメモリ使用量に応じて`f32`への変更も検討します。
- 高精度が要求される場合は、`Decimal`型の使用も検討します。

### 18.2 モジュール分割

- **汎用数値演算**: `math`モジュール内で管理し、他のシミュレーションモデルから独立して利用可能とします。
- **シミュレーションモデル**: `models`モジュール内で管理し、各オブジェクトごとに分割します。
- **ユーティリティ機能**: `utils`モジュール内で管理し、設定ファイルのパースなどを担当します。

### 18.3 並列化

- Rustの所有権モデルを活用しつつ、可能な箇所で並列処理を導入します。例えば、複数のミサイルオブジェクトの運動計算は並列化が可能です。
- 並列化に際しては、ステートフルなオブジェクトの共有を避け、関数型設計に基づくデータの分離を徹底します。

### 18.4 エラーハンドリング

- YAMLファイルのパースエラーや数値計算でのエラー（負の質量、`atan2`のゼロ近傍判定など）を適切にハンドリングし、ユーザに有用なエラーメッセージを提供します。
- エラー発生時には、シミュレーションを安全に停止し、ログに詳細情報を記録します。

## 19. まとめ

本設計書では、シミュレーションソフトウェアの基本設計を詳細に記述しました。以下のポイントを重視しています。

- **モジュール分割**: 汎用的な数値演算とシミュレーションモデルを分離し、再利用性と拡張性を確保。
- **関数型プログラミングの原則**: 副作用を最小限に抑え、純粋関数を活用。更新ロジックや判定ロジックは再利用可能な関数として実装。
- **ステートフルオブジェクトの活用**: 数値積分およびローパスフィルタにおいて必要な状態を`math`モジュール内のステートフルオブジェクトで管理。
- **明確なデータ構造**: YAML形式の入力ファイルとCSV形式の出力ファイルの構造を明確化。
- **エラー処理と数値安定性の確保**: 重要な計算において適切なエラーチェックを実装。

これにより、Rust初心者のプログラマでも迷うことなく実装を進められ、正確かつ効率的なシミュレーションソフトウェアの開発が可能となります。関数型設計に基づく明確な関数インタフェースとデータ構造により、実装ミスの最小化やテストの効率化が期待されます。

# 付録: 関数型設計の詳細インタフェース定義

以下に、`update_interceptor`、`update_missile`、`detect_missile`の計算を細かく純粋関数に分割し、それぞれのインタフェース定義を示します。

### 付録A: ミサイルの更新関数 (`update_missile`)

**目的**: ミサイルの現在の状態を基に、新しい状態を計算します。

**関数一覧**:

1. **vector_subtract**
   - **入力**: `a: &[f64; 3]`, `b: &[f64; 3]`
   - **出力**: `[f64; 3]`
   - **説明**: 2つのベクトルの差を計算します。

2. **vector_norm**
   - **入力**: `v: &[f64; 3]`
   - **出力**: `f64`
   - **説明**: ベクトルのノルム（長さ）を計算します。

3. **vector_normalize**
   - **入力**: `v: &[f64; 3]`
   - **出力**: `[f64; 3]`
   - **説明**: ベクトルを正規化します。

4. **calculate_acceleration**
   - **入力**: `params: &MissileParams`, `state: &MissileState`
   - **出力**: `[f64; 3]`
   - **説明**: 運動方程式に基づいて加速度を計算します。

5. **update_mass**
   - **入力**: `params: &MissileParams`, `state: &MissileState`, `dt: f64`
   - **出力**: `f64`
   - **説明**: 燃料消費による質量の更新を行います。

6. **update_state**
   - **入力**: `new_position: [f64; 3]`, `new_velocity: [f64; 3]`, `new_mass: f64`, `state: &MissileState`
   - **出力**: `MissileState`
   - **説明**: 新しい位置、速度、質量に基づいてミサイルの状態を更新します。

7. **update_missile**
   - **入力**:
     - `params: &MissileParams`
     - `state: &MissileState`
     - `integrators: &mut [AdamsBashforthIntegrator; 3]`
     - `filters: &mut [LowPassFilter; 3]`
     - `dt: f64`
   - **出力**: `MissileState`
   - **説明**: ミサイルの状態を更新するメイン関数です。

**コード例**:

```rust
use crate::math::integrator::AdamsBashforthIntegrator;
use crate::math::low_pass_filter::LowPassFilter;

/// 座標ベクトルの差を計算
pub fn vector_subtract(a: &[f64; 3], b: &[f64; 3]) -> [f64; 3] {
    [
        a[0] - b[0],
        a[1] - b[1],
        a[2] - b[2],
    ]
}

/// ベクトルのノルムを計算
pub fn vector_norm(v: &[f64; 3]) -> f64 {
    v.iter().map(|&x| x.powi(2)).sum::<f64>().sqrt()
}

/// ベクトルの正規化
pub fn vector_normalize(v: &[f64; 3]) -> [f64; 3] {
    let norm = vector_norm(v);
    if norm == 0.0 {
        [0.0, 0.0, 0.0]
    } else {
        [v[0] / norm, v[1] / norm, v[2] / norm]
    }
}

/// 加速度の計算
pub fn calculate_acceleration(
    params: &MissileParams,
    state: &MissileState,
) -> [f64; 3] {
    // 大気密度の計算
    let rho = params.rho0 * (-state.position[2] / params.h).exp();

    // 速度のノルム
    let speed = vector_norm(&state.velocity);

    // 空気抵抗の計算
    let drag = 0.5 * rho * params.cd * params.area * speed.powi(2);
    let drag_vector = [
        -drag * (state.velocity[0] / speed),
        -drag * (state.velocity[1] / speed),
        -drag * (state.velocity[2] / speed),
    ];

    // 重力の計算
    let gravity = [
        0.0,
        0.0,
        -params.g * state.mass,
    ];

    // 推力ベクトルの計算
    let thrust_vector = [
        params.thrust * state.theta.cos() * state.psi.cos(),
        params.thrust * state.theta.cos() * state.psi.sin(),
        params.thrust * state.theta.sin(),
    ];

    // 合力の計算
    [
        thrust_vector[0] + drag_vector[0] + gravity[0],
        thrust_vector[1] + drag_vector[1] + gravity[1],
        thrust_vector[2] + drag_vector[2] + gravity[2],
    ]
}

/// 質量の更新
pub fn update_mass(
    params: &MissileParams,
    state: &MissileState,
    dt: f64,
) -> f64 {
    let new_mass = state.mass - params.alpha * state.thrust * dt;
    if new_mass >= 0.0 { new_mass } else { 0.0 }
}

/// 状態の更新
pub fn update_state(
    new_position: [f64; 3],
    new_velocity: [f64; 3],
    new_mass: f64,
    state: &MissileState,
) -> MissileState {
    MissileState {
        mass: new_mass,
        thrust: state.thrust, // シナリオや制御により更新可能
        theta: state.theta,   // 制御により更新可能
        psi: state.psi,       // 制御により更新可能
        position: new_position,
        velocity: new_velocity,
    }
}

/// ミサイルの状態を更新する純粋関数
pub fn update_missile(
    params: &MissileParams,
    state: &MissileState,
    integrators: &mut [AdamsBashforthIntegrator; 3],
    filters: &mut [LowPassFilter; 3],
    dt: f64,
) -> MissileState {
    // 加速度の計算
    let acceleration = calculate_acceleration(params, state);

    // Adams-Bashforthによる速度の更新
    let mut new_velocity = [0.0; 3];
    for i in 0..3 {
        new_velocity[i] = integrators[i].integrate(acceleration[i], dt, state.velocity[i]);
    }

    // ローパスフィルタの適用
    for i in 0..3 {
        new_velocity[i] = filters[i].apply(new_velocity[i]);
    }

    // 位置の更新
    let new_position = [
        state.position[0] + new_velocity[0] * dt,
        state.position[1] + new_velocity[1] * dt,
        state.position[2] + new_velocity[2] * dt,
    ];

    // 質量の更新
    let new_mass = update_mass(params, state, dt);

    // 状態の更新
    let updated_state = update_state(new_position, new_velocity, new_mass, state);

    updated_state
}

/// 衝突判定関数
pub fn check_collision(state: &MissileState) -> bool {
    state.position[2] <= 0.0
}
```

### 付録B: 迎撃ミサイルの更新関数 (`update_interceptor`)

**目的**: 迎撃ミサイルの現在の状態を基に、新しい状態を計算します。

**関数一覧**:

1. **guidance**
   - **入力**: `interceptor: &InterceptorState`, `target_position: &[f64; 3]`, `guidance_constants: &GuidanceConstants`
   - **出力**: `[f64; 3]`
   - **説明**: 比例航法に基づき誘導加速度を計算します。

2. **calculate_drag**
   - **入力**: `cd: f64`, `area: f64`, `velocity: &[f64; 3]`
   - **出力**: `[f64; 3]`
   - **説明**: 迎撃ミサイルの空気抵抗を計算します。

3. **calculate_gravity**
   - **入力**: `g: f64`, `mass: f64`
   - **出力**: `[f64; 3]`
   - **説明**: 迎撃ミサイルに働く重力を計算します。

4. **calculate_thrust**
   - **入力**: `thrust: f64`, `theta: f64`, `psi: f64`
   - **出力**: `[f64; 3]`
   - **説明**: 迎撃ミサイルの推力ベクトルを計算します。

5. **calculate_total_force**
   - **入力**: `thrust: &[f64; 3]`, `drag: &[f64; 3]`, `gravity: &[f64; 3]`, `guidance_acceleration: &[f64; 3]`, `mass: f64`
   - **出力**: `[f64; 3]`
   - **説明**: 迎撃ミサイルに働く総合力を計算します。

6. **calculate_acceleration**
   - **入力**: `total_force: &[f64; 3]`, `mass: f64`
   - **出力**: `[f64; 3]`
   - **説明**: 迎撃ミサイルの加速度を計算します。

7. **update_mass_interceptor**
   - **入力**: `alpha: f64`, `thrust: f64`, `dt: f64`
   - **出力**: `f64`
   - **説明**: 燃料消費による迎撃ミサイルの質量更新を行います。

8. **update_state_interceptor**
   - **入力**: `new_position: [f64; 3]`, `new_velocity: [f64; 3]`, `new_mass: f64`, `state: &InterceptorState`
   - **出力**: `InterceptorState`
   - **説明**: 新しい位置、速度、質量に基づいて迎撃ミサイルの状態を更新します。

9. **update_interceptor**
   - **入力**:
     - `params: &InterceptorParams`
     - `state: &InterceptorState`
     - `target_position: &[f64; 3]`
     - `integrators: &mut [AdamsBashforthIntegrator; 3]`
     - `filters: &mut [LowPassFilter; 3]`
     - `dt: f64`
   - **出力**: `InterceptorState`
   - **説明**: 迎撃ミサイルの状態を更新するメイン関数です。

10. **launch_interceptor**
    - **入力**: `state: &InterceptorState`
    - **出力**: `InterceptorState`
    - **説明**: 迎撃ミサイルの発射を開始します。

11. **check_interception**
    - **入力**: `interceptor: &InterceptorState`, `missile: &MissileState`, `interception_distance: f64`
    - **出力**: `bool`
    - **説明**: 迎撃ミサイルがミサイルを迎撃したかを判定します。

**コード例**:

```rust
use crate::math::integrator::AdamsBashforthIntegrator;
use crate::math::low_pass_filter::LowPassFilter;
use crate::models::missile::MissileState;

/// 誘導加速度計算関数（比例航法）
pub fn guidance(
    interceptor: &InterceptorState,
    target_position: &[f64; 3],
    guidance_constants: &GuidanceConstants,
) -> [f64; 3] {
    let los = vector_subtract(&target_position, &interceptor.position);
    let los_norm = vector_norm(&los);
    let los_unit = if los_norm == 0.0 {
        [0.0, 0.0, 0.0]
    } else {
        vector_normalize(&los)
    };

    // LOS角速度（簡略化のためにゼロとする）
    let lambda_dot = 0.0;

    // 誘導加速度の計算
    [
        guidance_constants.n * interceptor.velocity[0] * lambda_dot * los_unit[0],
        guidance_constants.n * interceptor.velocity[1] * lambda_dot * los_unit[1],
        guidance_constants.n * interceptor.velocity[2] * lambda_dot * los_unit[2],
    ]
}

/// 空気抵抗計算関数
pub fn calculate_drag(
    cd: f64,
    area: f64,
    velocity: &[f64; 3],
) -> [f64; 3] {
    let speed = vector_norm(velocity);
    let drag = 0.5 * cd * area * speed.powi(2);
    [
        -drag * (velocity[0] / speed),
        -drag * (velocity[1] / speed),
        -drag * (velocity[2] / speed),
    ]
}

/// 重力計算関数
pub fn calculate_gravity(g: f64, mass: f64) -> [f64; 3] {
    [0.0, 0.0, -g * mass]
}

/// 推力ベクトル計算関数
pub fn calculate_thrust(thrust: f64, theta: f64, psi: f64) -> [f64; 3] {
    [
        thrust * theta.cos() * psi.cos(),
        thrust * theta.cos() * psi.sin(),
        thrust * theta.sin(),
    ]
}

/// 合力計算関数
pub fn calculate_total_force(
    thrust: &[f64; 3],
    drag: &[f64; 3],
    gravity: &[f64; 3],
    guidance_acceleration: &[f64; 3],
    mass: f64,
) -> [f64; 3] {
    [
        thrust[0] + drag[0] + gravity[0] + guidance_acceleration[0] * mass,
        thrust[1] + drag[1] + gravity[1] + guidance_acceleration[1] * mass,
        thrust[2] + drag[2] + gravity[2] + guidance_acceleration[2] * mass,
    ]
}

/// 加速度計算関数
pub fn calculate_acceleration(total_force: &[f64; 3], mass: f64) -> [f64; 3] {
    [
        total_force[0] / mass,
        total_force[1] / mass,
        total_force[2] / mass,
    ]
}

/// 質量の更新
pub fn update_mass_interceptor(
    alpha: f64,
    thrust: f64,
    dt: f64,
) -> f64 {
    let new_mass = thrust * alpha * dt;
    if new_mass >= 0.0 { new_mass } else { 0.0 }
}

/// 状態の更新
pub fn update_state_interceptor(
    new_position: [f64; 3],
    new_velocity: [f64; 3],
    new_mass: f64,
    state: &InterceptorState,
) -> InterceptorState {
    InterceptorState {
        mass: new_mass,
        thrust: state.thrust, // シナリオや制御により更新可能
        theta: state.theta,   // 誘導により更新可能
        psi: state.psi,       // 誘導により更新可能
        position: new_position,
        velocity: new_velocity,
        launched: state.launched,
    }
}

/// 迎撃ミサイルの状態を更新する純粋関数
pub fn update_interceptor(
    params: &InterceptorParams,
    state: &InterceptorState,
    target_position: &[f64; 3],
    integrators: &mut [AdamsBashforthIntegrator; 3],
    filters: &mut [LowPassFilter; 3],
    dt: f64,
) -> InterceptorState {
    if !state.launched {
        return state.clone();
    }

    // 誘導加速度の計算
    let a_guidance = guidance(state, target_position, &params.guidance_constants);

    // 空気抵抗の計算
    let drag = calculate_drag(params.cd, params.area, &state.velocity);

    // 重力の計算
    let gravity = calculate_gravity(params.g, state.mass);

    // 推力ベクトルの計算
    let thrust = calculate_thrust(params.thrust, state.theta, state.psi);

    // 合力の計算
    let total_force = calculate_total_force(&thrust, &drag, &gravity, &a_guidance, state.mass);

    // 加速度の計算
    let acceleration = calculate_acceleration(&total_force, state.mass);

    // Adams-Bashforthによる速度の更新
    let mut new_velocity = [0.0; 3];
    for i in 0..3 {
        new_velocity[i] = integrators[i].integrate(acceleration[i], dt, state.velocity[i]);
    }

    // ローパスフィルタの適用
    for i in 0..3 {
        new_velocity[i] = filters[i].apply(new_velocity[i]);
    }

    // 位置の更新
    let new_position = [
        state.position[0] + new_velocity[0] * dt,
        state.position[1] + new_velocity[1] * dt,
        state.position[2] + new_velocity[2] * dt,
    ];

    // 質量の更新
    let new_mass = update_mass_interceptor(params.alpha, state.thrust, dt);
    let mass = if new_mass >= 0.0 { new_mass } else { 0.0 };

    // 状態の更新
    let updated_state = update_state_interceptor(new_position, new_velocity, mass, state);

    updated_state
}

/// 迎撃ミサイルの発射関数
pub fn launch_interceptor(state: &InterceptorState) -> InterceptorState {
    InterceptorState {
        launched: true,
        ..*state
    }
}

/// 迎撃判定関数
pub fn check_interception(
    interceptor: &InterceptorState,
    missile: &MissileState,
    interception_distance: f64,
) -> bool {
    let relative_position = vector_subtract(&interceptor.position, &missile.position);
    vector_norm(&relative_position) <= interception_distance
}
```

### 付録C: detect_missile関数の更新

**目的**: レーダによるミサイルの検出を行います。

**関数一覧**:

1. **vector_subtract**
   - **入力**: `a: &[f64; 3]`, `b: &[f64; 3]`
   - **出力**: `[f64; 3]`
   - **説明**: 2つのベクトルの差を計算します。

2. **vector_norm**
   - **入力**: `v: &[f64; 3]`
   - **出力**: `f64`
   - **説明**: ベクトルのノルム（長さ）を計算します。

3. **vector_normalize**
   - **入力**: `v: &[f64; 3]`
   - **出力**: `[f64; 3]`
   - **説明**: ベクトルを正規化します。

4. **vector_dot**
   - **入力**: `a: &[f64; 3]`, `b: &[f64; 3]`
   - **出力**: `f64`
   - **説明**: 2つのベクトルの内積を計算します。

5. **calculate_delta_azimuth**
   - **入力**: `radar_dir: &[f64; 3]`, `target_dir: &[f64; 3]`
   - **出力**: `f64`
   - **説明**: 方位角差を計算します。

6. **calculate_delta_elevation**
   - **入力**: `radar_dir: &[f64; 3]`, `target_dir: &[f64; 3]`
   - **出力**: `f64`
   - **説明**: 仰角差を計算します。

7. **is_atan2_near_zero**
   - **入力**: `x: f64`, `y: f64`, `epsilon: f64`
   - **出力**: `bool`
   - **説明**: `atan2`の入力がゼロ近傍かを判定します。

8. **distance_check**
   - **入力**: `radar: &Radar`, `missile: &MissileState`
   - **出力**: `bool`
   - **説明**: ミサイルが探知距離内にあるかを判定します。

9. **angle_check**
   - **入力**: `radar: &Radar`, `missile: &MissileState`, `epsilon: f64`
   - **出力**: `bool`
   - **説明**: ミサイルが角度範囲内にあるかを判定します。

10. **detect_missile**
    - **入力**: `radar: &Radar`, `missile: &MissileState`, `epsilon: f64`
    - **出力**: `DetectionResult`
    - **説明**: ミサイルがレーダに検出されたかを判定し、検出結果を返します。

**コード例**:

```rust
use crate::models::missile::MissileState;

/// ベクトルの内積を計算
pub fn vector_dot(a: &[f64; 3], b: &[f64; 3]) -> f64 {
    a.iter().zip(b.iter()).map(|(&x, &y)| x * y).sum()
}

/// 座標ベクトルの差を計算（再利用）
pub fn vector_subtract(a: &[f64; 3], b: &[f64; 3]) -> [f64; 3] {
    [
        a[0] - b[0],
        a[1] - b[1],
        a[2] - b[2],
    ]
}

/// ベクトルのノルムを計算（再利用）
pub fn vector_norm(v: &[f64; 3]) -> f64 {
    v.iter().map(|&x| x.powi(2)).sum::<f64>().sqrt()
}

/// ベクトルの正規化（再利用）
pub fn vector_normalize(v: &[f64; 3]) -> [f64; 3] {
    let norm = vector_norm(v);
    if norm == 0.0 {
        [0.0, 0.0, 0.0]
    } else {
        [v[0] / norm, v[1] / norm, v[2] / norm]
    }
}

/// 方位角差の計算関数
pub fn calculate_delta_azimuth(radar_dir: &[f64; 3], target_dir: &[f64; 3]) -> f64 {
    let dot = vector_dot(radar_dir, target_dir);
    let delta = dot.acos().to_degrees();
    delta
}

/// 仰角差の計算関数
pub fn calculate_delta_elevation(radar_dir: &[f64; 3], target_dir: &[f64; 3]) -> f64 {
    let dot = vector_dot(radar_dir, target_dir);
    let norm_product = vector_norm(radar_dir) * vector_norm(target_dir);
    if norm_product == 0.0 {
        0.0
    } else {
        (dot / norm_product).acos().to_degrees()
    }
}

/// `atan2`のゼロ近傍判定関数
pub fn is_atan2_near_zero(x: f64, y: f64, epsilon: f64) -> bool {
    x.abs() < epsilon && y.abs() < epsilon
}

/// 探知関数: 距離判定
pub fn distance_check(radar: &Radar, missile: &MissileState) -> bool {
    let relative_position = vector_subtract(&missile.position, &radar.params.position);
    let distance = vector_norm(&relative_position);
    distance <= radar.params.range
}

/// 探知関数: 角度判定
pub fn angle_check(radar: &Radar, missile: &MissileState, epsilon: f64) -> bool {
    let relative_position = vector_subtract(&missile.position, &radar.params.position);
    let distance = vector_norm(&relative_position);
    let target_direction = if distance == 0.0 {
        [0.0, 0.0, 0.0]
    } else {
        vector_normalize(&relative_position)
    };
    let radar_direction = vector_normalize(&radar.params.direction);

    // atan2のゼロ近傍判定
    if is_atan2_near_zero(radar.params.direction[0], radar.params.direction[1], epsilon) &&
       is_atan2_near_zero(target_direction[0], target_direction[1], epsilon) {
        return false;
    }

    let delta_azimuth = calculate_delta_azimuth(&radar_direction, &target_direction);
    let delta_elevation = calculate_delta_elevation(&radar_direction, &target_direction);

    delta_azimuth <= (radar.params.azimuth_range / 2.0) &&
    delta_elevation <= (radar.params.elevation_range / 2.0)
}

/// 探知関数: 全体判定
pub fn detect_missile(
    radar: &Radar,
    missile: &MissileState,
    epsilon: f64,
) -> DetectionResult {
    let detected = distance_check(radar, missile) && angle_check(radar, missile, epsilon);

    if detected {
        DetectionResult {
            detected: true,
            missile_position: Some(missile.position),
            missile_orientation: Some([missile.theta, missile.psi, 0.0]),
            detection_position: Some(radar.params.position),
        }
    } else {
        DetectionResult {
            detected: false,
            missile_position: None,
            missile_orientation: None,
            detection_position: None,
        }
    }
}

/// 発射指示を生成する関数
pub fn generate_fire_command(detection: &DetectionResult) -> bool {
    detection.detected
}
```

## 付録D: モジュール間の依存関係

以下に、各モジュール間の依存関係を示します。

- **main.rs**
  - 依存: `models`, `math`, `utils`
- **mathモジュール**
  - 依存: なし
- **modelsモジュール**
  - 依存: `math`
- **utilsモジュール**
  - 依存: `serde`, `serde_yaml`

## 付録E: テストケース例

### 付録E1: ミサイルの更新関数のテスト

**目的**: ミサイルの運動更新が正確に行われることを確認します。

**テストケース**:

1. **初期条件**
   - 質量: 1000.0 kg
   - 推力: 5000.0 N
   - θ: 0.0 rad
   - ψ: 0.0 rad
   - 位置: [0.0, 0.0, 1000.0] m
   - 速度: [100.0, 0.0, 0.0] m/s

2. **期待される結果**
   - 質量が減少していること
   - 位置と速度が更新されていること
   - 空気抵抗と重力が加速度に正しく反映されていること

**実装例**:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::math::{AdamsBashforthIntegrator, LowPassFilter};

    #[test]
    fn test_update_missile() {
        let params = MissileParams {
            alpha: 0.01,
            cd: 0.5,
            area: 1.0,
            rho0: 1.225,
            h: 8500.0,
            g: 9.81,
            alpha_filter: 0.1,
        };

        let state = MissileState {
            mass: 1000.0,
            thrust: 5000.0,
            theta: 0.0,
            psi: 0.0,
            position: [0.0, 0.0, 1000.0],
            velocity: [100.0, 0.0, 0.0],
        };

        let mut integrators = [
            AdamsBashforthIntegrator::new(),
            AdamsBashforthIntegrator::new(),
            AdamsBashforthIntegrator::new(),
        ];

        let mut filters = [
            LowPassFilter::new(params.alpha_filter),
            LowPassFilter::new(params.alpha_filter),
            LowPassFilter::new(params.alpha_filter),
        ];

        let dt = 0.1;

        let updated_state = update_missile(&params, &state, &mut integrators, &mut filters, dt);

        // 質量の減少を確認
        assert!(updated_state.mass < state.mass);

        // 位置と速度の更新を確認
        assert_ne!(updated_state.position, state.position);
        assert_ne!(updated_state.velocity, state.velocity);
    }
}
```

### 付録E2: レーダの検出関数のテスト

**目的**: レーダがミサイルを正しく検出できることを確認します。

**テストケース**:

1. **ミサイルが検出範囲内かつ角度範囲内**
   - 期待される結果: 検出成功

2. **ミサイルが検出範囲外**
   - 期待される結果: 検出失敗

3. **ミサイルが角度範囲外**
   - 期待される結果: 検出失敗

4. **`atan2`のゼロ近傍判定**
   - 期待される結果: 検出失敗

**実装例**:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_detect_missile_success() {
        let radar = Radar {
            params: RadarParams {
                position: [0.0, 0.0, 0.0],
                direction: [1.0, 0.0, 0.0],
                range: 10000.0,
                azimuth_range: 45.0,
                elevation_range: 30.0,
                period: 0.1,
            },
        };

        let missile = MissileState {
            mass: 1000.0,
            thrust: 5000.0,
            theta: 0.0,
            psi: 0.0,
            position: [5000.0, 0.0, 0.0],
            velocity: [100.0, 0.0, 0.0],
        };

        let epsilon = 1e-6;

        let detection = detect_missile(&radar, &missile, epsilon);
        assert!(detection.detected);
    }

    #[test]
    fn test_detect_missile_out_of_range() {
        let radar = Radar {
            params: RadarParams {
                position: [0.0, 0.0, 0.0],
                direction: [1.0, 0.0, 0.0],
                range: 10000.0,
                azimuth_range: 45.0,
                elevation_range: 30.0,
                period: 0.1,
            },
        };

        let missile = MissileState {
            mass: 1000.0,
            thrust: 5000.0,
            theta: 0.0,
            psi: 0.0,
            position: [15000.0, 0.0, 0.0],
            velocity: [100.0, 0.0, 0.0],
        };

        let epsilon = 1e-6;

        let detection = detect_missile(&radar, &missile, epsilon);
        assert!(!detection.detected);
    }

    #[test]
    fn test_detect_missile_out_of_angle() {
        let radar = Radar {
            params: RadarParams {
                position: [0.0, 0.0, 0.0],
                direction: [1.0, 0.0, 0.0],
                range: 10000.0,
                azimuth_range: 45.0,
                elevation_range: 30.0,
                period: 0.1,
            },
        };

        let missile = MissileState {
            mass: 1000.0,
            thrust: 5000.0,
            theta: 0.0,
            psi: 0.0,
            position: [5000.0, 5000.0, 0.0],
            velocity: [100.0, 0.0, 0.0],
        };

        let epsilon = 1e-6;

        let detection = detect_missile(&radar, &missile, epsilon);
        assert!(!detection.detected);
    }

    #[test]
    fn test_detect_missile_atan2_near_zero() {
        let radar = Radar {
            params: RadarParams {
                position: [0.0, 0.0, 0.0],
                direction: [0.0, 0.0, 0.0],
                range: 10000.0,
                azimuth_range: 45.0,
                elevation_range: 30.0,
                period: 0.1,
            },
        };

        let missile = MissileState {
            mass: 1000.0,
            thrust: 5000.0,
            theta: 0.0,
            psi: 0.0,
            position: [0.0, 0.0, 0.0],
            velocity: [0.0, 0.0, 0.0],
        };

        let epsilon = 1e-6;

        let detection = detect_missile(&radar, &missile, epsilon);
        assert!(!detection.detected);
    }
}
```

### 付録E3: 迎撃ミサイルの更新関数のテスト

**目的**: 迎撃ミサイルの運動更新が正確に行われることを確認します。

**テストケース**:

1. **初期条件**
   - 質量: 500.0 kg
   - 推力: 3000.0 N
   - θ: 0.0 rad
   - ψ: 0.0 rad
   - 位置: [0.0, 0.0, 0.0] m
   - 速度: [0.0, 0.0, 0.0] m/s
   - 発射フラグ: `false`

2. **期待される結果**
   - 発射前は状態が変化しないこと
   - 発射後、質量が減少し、位置と速度が更新されること
   - 誘導加速度が正しく反映されていること

**実装例**:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::math::{AdamsBashforthIntegrator, LowPassFilter};

    #[test]
    fn test_update_interceptor_not_launched() {
        let params = InterceptorParams {
            alpha: 0.02,
            cd: 0.4,
            area: 0.8,
            g: 9.81,
            thrust: 3000.0,
            alpha_filter: 0.1,
            guidance_constants: GuidanceConstants { n: 0.1 },
        };

        let state = InterceptorState {
            mass: 500.0,
            thrust: 3000.0,
            theta: 0.0,
            psi: 0.0,
            position: [0.0, 0.0, 0.0],
            velocity: [0.0, 0.0, 0.0],
            launched: false,
        };

        let target_position = [1000.0, 0.0, 0.0];

        let mut integrators = [
            AdamsBashforthIntegrator::new(),
            AdamsBashforthIntegrator::new(),
            AdamsBashforthIntegrator::new(),
        ];

        let mut filters = [
            LowPassFilter::new(params.alpha_filter),
            LowPassFilter::new(params.alpha_filter),
            LowPassFilter::new(params.alpha_filter),
        ];

        let dt = 0.1;

        let updated_state = update_interceptor(&params, &state, &target_position, &mut integrators, &mut filters, dt);

        // 発射前は状態が変化しないことを確認
        assert_eq!(updated_state, state);
    }

    #[test]
    fn test_update_interceptor_launched() {
        let params = InterceptorParams {
            alpha: 0.02,
            cd: 0.4,
            area: 0.8,
            g: 9.81,
            thrust: 3000.0,
            alpha_filter: 0.1,
            guidance_constants: GuidanceConstants { n: 0.1 },
        };

        let state = InterceptorState {
            mass: 500.0,
            thrust: 3000.0,
            theta: 0.0,
            psi: 0.0,
            position: [0.0, 0.0, 0.0],
            velocity: [0.0, 0.0, 0.0],
            launched: true,
        };

        let target_position = [1000.0, 0.0, 0.0];

        let mut integrators = [
            AdamsBashforthIntegrator::new(),
            AdamsBashforthIntegrator::new(),
            AdamsBashforthIntegrator::new(),
        ];

        let mut filters = [
            LowPassFilter::new(params.alpha_filter),
            LowPassFilter::new(params.alpha_filter),
            LowPassFilter::new(params.alpha_filter),
        ];

        let dt = 0.1;

        let updated_state = update_interceptor(&params, &state, &target_position, &mut integrators, &mut filters, dt);

        // 質量の減少を確認
        assert!(updated_state.mass < state.mass);

        // 位置と速度の更新を確認
        assert_ne!(updated_state.position, state.position);
        assert_ne!(updated_state.velocity, state.velocity);
    }
}
```

# 終わりに

本設計書は、関数型プログラミングの原則に基づいた設計を詳細に記述しました。各更新ロジックや判定ロジックを細分化し、純粋関数として実装することで、再利用性とテスト容易性を向上させています。また、ステートフルなオブジェクトは`math`モジュール内で管理し、モデルモジュールは純粋関数で構成することで、関数型設計のメリットを最大限に活用しています。

この設計に基づき、Rust初心者のプログラマでも迷わず実装を進められ、正確かつ効率的なシミュレーションソフトウェアの開発が可能となることを目指します。